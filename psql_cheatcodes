POSTGRESS CHEATCODES

sudo -i -u postgres / licenta_admin
psql

\l -> listeaza baze de date
\c <nume_bd> -> te conecteaza la baza de date specificata
\COPY products(name, raw_price, raw_rating, is_in_stock, url, product_code, retailer, imagepath, category) FROM '/home/tavi/Desktop/licenta/scraping/evomag/evomag_scrape_new.csv' DELIMITER ',' CSV HEADER;
\COPY products(name, raw_price, raw_rating, is_in_stock, url, product_code, retailer, imagepath, category) FROM '/home/tavi/Desktop/licenta/scraping/vexio/vexio_scrape_jpgs.csv' DELIMITER ',' CSV HEADER;




===================workink========================================

CREATE OR REPLACE FUNCTION assign_categories_test(OUT p_product_code VARCHAR(255), OUT p_duplicates_number INTEGER ) RETURNS SETOF RECORD AS $$
DECLARE
	duplicates_cursor CURSOR FOR
	        SELECT product_code, COUNT(product_code) as num_of_duplicates FROM products GROUP BY product_code HAVING COUNT(product_code) > 1;
	iterator RECORD;
BEGIN
	OPEN duplicates_cursor;
	LOOP
	        FETCH NEXT FROM duplicates_cursor INTO iterator;
	        EXIT WHEN NOT FOUND;
	        
	        p_product_code := iterator.product_code;
	        p_duplicates_number := iterator.num_of_duplicates;
	        
	        UPDATE products 
	        SET category = 'found'
	        WHERE product_code = iterator.product_code;
	        
	        RETURN NEXT;
	END LOOP; 
	CLOSE duplicates_cursor;
END;
$$
LANGUAGE PLPGSQL;

===================workink========================================

CREATE OR REPLACE FUNCTION assign_categories(OUT p_product_code VARCHAR(255), OUT p_duplicates_number INTEGER ) RETURNS SETOF RECORD AS $$
DECLARE
	duplicates_cursor CURSOR FOR
	        SELECT product_code, COUNT(product_code) as num_of_duplicates FROM products GROUP BY product_code HAVING COUNT(product_code) > 1;
	iterator RECORD;
	p_category_evomag VARCHAR(225);
	p_category_vexio VARCHAR(225);
BEGIN
	OPEN duplicates_cursor;
	LOOP
	        FETCH NEXT FROM duplicates_cursor INTO iterator;
	        EXIT WHEN NOT FOUND;
	        
	        p_product_code := iterator.product_code;
	        p_duplicates_number := iterator.num_of_duplicates;
	        
	        SELECT category 
	        INTO p_category_evomag
	        FROM products
	        WHERE retailer LIKE 'evomag' AND product_code LIKE p_product_code;
	        
		SELECT category 
	        INTO p_category_vexio
	        FROM products
	        WHERE retailer LIKE 'vexio' AND product_code LIKE p_product_code;
	        
	       	RAISE NOTICE 'EVOMAG: % - VEXIO: %', p_category_evomag, p_category_vexio;
	       	
	       	IF p_category_evomag NOT LIKE p_category_vexio THEN
			UPDATE products
			SET category = p_category_vexio
			WHERE category like p_category_evomag; 
	        END IF;
	        RETURN NEXT;
	END LOOP; 
	CLOSE duplicates_cursor;
END;
$$
LANGUAGE PLPGSQL;

==============test=================================================
UPDATE products_test
SET raw_price = floor(random() * (1500 - 50 + 1) + 50);
--------------------------
select MIN(products.raw_price) as og_raw_price, MIN(products_test.raw_price) as newest_raw_price, products.product_code
 from products
 join products_test ON products.product_code = products_test.product_code 
 GROUP BY products.product_code;
--------------------------
!!!god_script

DO $$
DECLARE
    sql_query TEXT := 'SELECT * FROM table1';  -- Start with base query
    join_clause TEXT;
    i INT;
    table_names TEXT[] := ARRAY['table2', 'table3', 'table4'];  -- Array of tables to join
BEGIN
    FOR i IN 1..array_length(table_names, 1) LOOP
        join_clause := ' INNER JOIN ' || table_names[i] || ' ON table1.id = ' || table_names[i] || '.table1_id';
        sql_query := sql_query || join_clause;
    END LOOP;

    -- Execute the dynamic query
    EXECUTE sql_query;
END $$; 
--------------------------
SELECT tablename
FROM pg_catalog.pg_tables
WHERE schemaname = 'public'
--------------------------
SELECT ARRAY(SELECT tablename
                 FROM pg_catalog.pg_tables
                 WHERE schemaname = 'public') INTO table_names;
--------------------------  


DO $$
DECLARE
	select_clause TEXT := 'CREATE OR REPLACE VIEW price_history_view as select products.product_code, ';
    join_clause TEXT;
    i INT;
    table_names TEXT[];
BEGIN
    SELECT ARRAY(SELECT tablename
                 FROM pg_catalog.pg_tables
                 WHERE schemaname = 'public') INTO table_names;
	
    FOR i IN 1..array_length(table_names, 1) LOOP
		select_clause := select_clause || ' MIN(' || table_names[i] || '.raw_price) as price_' || table_names[i] || ',';

    END LOOP;
    
    select_clause := LEFT(select_clause, length(select_clause) - 1);
	select_clause := select_clause || E'\n' || E'FROM products';
	
	RAISE NOTICE 'select_clause: %', select_clause;
	 
    FOR i IN 1..array_length(table_names, 1) LOOP
    
    	IF table_names[i] NOT LIKE 'products' THEN
    		
			select_clause := select_clause || E'\nFULL OUTER JOIN ' || table_names[i] 
			|| ' ON products.product_code = ' || table_names[i] || '.product_code';
		 
		END IF;
    END LOOP;
    
    select_clause := select_clause || E'\nGROUP BY products.product_code;';
    
    RAISE NOTICE 'select_clause: %', select_clause;
	EXECUTE select_clause;
END $$; 

================================================

GODLY SQL_QUERY

SELECT * 
FROM products
WHERE to_tsvector(name) @@ plainto_tsquery(?1) AND 
	raw_price BETWEEN ?4 AND ?5 AND 
	category LIKE COALESCE(NULLIF(:category_param, 'undefined'), '%') 
LIMIT ?2 OFFSET (?3-1) * ?2










